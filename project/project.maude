mod INT-LIST is protecting INT .
	sort IntList .
	subsort Int < IntList .
	op nil : -> IntList .
	op __ : IntList IntList -> IntList [assoc id: nil] .
	op _in_ : Int IntList -> Bool .
	var I : Int . vars L L' : IntList .
	eq I in L I L' = true .
	eq I in L = false [owise] .

	rl 2 3 => 9 .
endm

parse 1 2 3 4 5 .

rewrite 1 in 2 3 1 3 .
rewrite 1 2 3 4 5 6 .


mod CHANGE is protecting INT .
	sorts Change .

	op __ : Change Change -> Change [assoc] .
	ops C1 C2 C3 C4 C5 : -> Change .
	ops CREF1 CREF2 CREF3 : -> Change .

	rl C1 C2 => CREF1 .
	rl C4 C5 => CREF2 .
	rl C1 C3 C5 => CREF3 .

endm

rewrite C1 C2 C3 C4 C5 C1 C3 C2 C4 C5 C1 C3 C5 C1 C2 C4 C5 C1 .



mod CHANGE2 is protecting INT + BOOL + STRING .
	sorts Change .

	op __ : Change Change -> Change [assoc] .
	op change : String Int -> Change .
	op match : Change Change -> Bool .
	ops CA, CB, CC, CREF1 : -> Change .

	vars Property1 Property2 : Int .
	vars C1 C2 C3 : Change .
	vars ID1 ID2 : String .

	eq CA = change("a", 4) .
	eq CB = change("b", 5) .
	eq CC = change("c", 6) .
	eq CREF1 = change("refactoring 1", 0) .

	eq match(change(ID1, Property1), change(ID2, Property2)) = if ID1 == ID2 and Property1 == Property2 then true else false fi .
	
	
	crl C1 C2 => CREF1 if match(CA, C1) => true /\ match(CB, C2) => true . 

endm

---set trace on .

rewrite CA CB .

rewrite change("a", 2) change("b", 5) change("a", 4) change("b", 5) .

q .