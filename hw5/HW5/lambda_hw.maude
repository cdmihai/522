*** Copyright 2013, Grigore Rosu (University of Illinois). ***

--- This file contains various definitions of untyped lambda calculi,
--- some based on substitution, others based on combinators, and others
--- based on de Bruijn nameless encodings.  There are four places
--- where the definition can be configured, indicated by comments
--- of the form "!!!SETTING n!!!", with n in {1,2,3,4}.  Specifically,
--- !!!SETTING 1!!! allows to pick a lambda abstraction which is
--- either restricted to prohibit reductions in its body or unrestricted;
--- !!!SETTING 2!!! allows to pick an application operation which is either
--- unrestricted or prohibits reductions in the argument (call-by-name);
--- !!!SETTING 3!!! is only related to de Bruijn and allows to either
--- include the conventional de Bruijn technique or the optimized one;
--- !!!SETTING 4!!! allows to pick a particular kind of lambda calculus, that
--- is, standard, call-by-value, with combinators, or with de Bruijn.

--- Example 01: Substitution-based, standard lambda-calculus; that is,
--- unrestricted lambda-abstraction and unrestricted application
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 02: Substitution-based lambda-calculus
--- with no reductions in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 03: Substitution-based call-by-name lambda-calculus
--- with reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 04: Substitution-based call-by-name lambda-calculus
--- with no reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 05: Substitution-based call-by-value lambda-calculus
--- with reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = irrelevant
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-CALL-BY-VALUE

--- Example 06: Substitution-based call-by-value lambda-calculus
--- with no reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = irrelevant
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-CALL-BY-VALUE

--- Example 07: Combinators-based lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-WITH-COMBINATORS

--- Example 08: Combinators-based lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-WITH-COMBINATORS

--- Example 09: De Bruijn lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = DE-BRUIJN
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 10: De Bruijn lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = DE-BRUIJN
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 11: Optimized De Bruijn lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = DE-BRUIJN-OPTIMIZED
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 12: Optimized De Bruijn lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = DE-BRUIJN-OPTIMIZED
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

in builtins

mod GENERIC-EXPRESSION is
  including PL-ID .
  sorts Var Builtin Exp .
  subsort Id < Var .
  subsort Var Builtin < Exp .
endm

mod LAMBDA-ABSTRACTION-UNRESTRICTED is
  including GENERIC-EXPRESSION .
--- Unrestricted lambda abstraction means that reductions can also take place
--- inside its body.  So no strategy is defined for /\_._
  op /\_._ : Var Exp -> Exp [prec 50] .
endm

mod LAMBDA-ABSTRACTION-RESTRICTED is
  including GENERIC-EXPRESSION .
--- Restricted lambda abstraction means that reductions are forbidden
--- to take place inside its body.  So a strategy is defined for /\_._
  op /\_._ : Var Exp -> Exp [frozen(2) prec 50] .
endm

mod LAMBDA-ABSTRACTION is
--- !!!SETTING 1!!!
--- Pick one of the following:
---  including LAMBDA-ABSTRACTION-UNRESTRICTED .
  including LAMBDA-ABSTRACTION-RESTRICTED .
endm

mod APPLICATION-UNRESTRICTED is
  including GENERIC-EXPRESSION .
--- Unrestricted application means that reductions can take place
--- anywhere (both in the function and in its argument)
  op __ : Exp Exp -> Exp [prec 25 gather(E e)] .  --- left associative, binds tighter than /\_._
endm

mod APPLICATION-CALL-BY-NAME is
  including GENERIC-EXPRESSION .
--- Call-by-name means that only the first argument (the function) of
--- the application needs to be be reduced before the application takes place.
--- The second argument is not reduced at all.
  op __ : Exp Exp -> Exp [frozen(2) prec 25 gather(E e)] .
endm

mod APPLICATION is
--- !!!SETTING 2!!!
--- Pick one of the following:
  including APPLICATION-UNRESTRICTED .
---  including APPLICATION-CALL-BY-NAME .
endm

mod SUBSTITUTION is
  including PL-GENERIC-SUBSTITUTION .
  including LAMBDA-ABSTRACTION .
  subsort Exp < GenericTerm .
  eq bind('/\_._) = 1 .
  op _[_/_] : Exp Exp Var -> Exp .
  vars E F : Exp .  var X : Id .
  eq E[F / X] = substitute(E, F, X) .
endm

mod TEST-SUBSTITUTION is
  including SUBSTITUTION .
  including APPLICATION .
endm

--- Testing substitution (variable capture)
rew (/\ x . /\ y . x y z)[x / z] .
rew (/\ u . /\ x . /\ y . x y z)[x / z] .
rew ((/\ x . x z) (/\ x . /\ y . x y z))[x / z] .

mod LAMBDA-STANDARD is
  including SUBSTITUTION .
  including APPLICATION .
  var X : Var .  var E F : Exp .
--- Comment the next rule out to see how big the deasugared
--- lambda terms are before lambda reduction.
--- Note that sometimes one may get much faster rewrites if one
--- makes the rule below an equation instead of a rule.
--- However, one should be careful with this, because equations
--- do not obey the frozeness declarations, so one will not
--- achieve the desired evaluation strategy; in particular,
--- one may have non-termination where it should terminate.
  rl (/\ X . E) F => E[F / X] .  --- beta reduction
endm

mod LAMBDA-CALL-BY-VALUE is
--- Call-by-value lambda calculus differs from other variants of lambda
--- calculus in that beta reduction is applied only after the two arguments
--- of the application operation are fully evaluated.  To distinguish
--- the fully evaluated expressions from the other, a new syntactic
--- category of values, Val, is typically introduced.  Note that the
--- beta reduction rule below requires F to be of sort Val.
--- Also, note that in addition to variables and builtins, the lambda
--- abstraction is also added as a construct for values.  Maude's
--- least-sort computation mechanism will guarantee that terms are
--- always sorted to Val whenever possible, in spite of the overloaded
--- lambda abstraction.  Call-by-value works best when the lambda-abstraction
--- is restricted to not evaluate its argument, that is, when we include
--- LAMBDA-ABSTRACTION-RESTRICTED in module LAMBDA-ABSTRACTION above.
--- Also, the application operation has to be allowed to evaluate both
--- its arguments, which is why APPLICATION-UNRESTRICTED is included below.
  including SUBSTITUTION .
  including APPLICATION-UNRESTRICTED .
  var X : Var .  var E : Exp .  var F : Val .
  sort Val .
  subsorts Var Builtin < Val < Exp .
  op /\_._ : Var Exp -> Val [ditto] .
  rl (/\ X . E) F => E[F / X] .  --- beta reduction
endm

mod DE-BRUIJN-SYNTAX is
  including APPLICATION .
  including PL-INT .
--- Like in the standard lambda-calculus, both restricted and unrestricted
--- lambda abstraction make sense.  However, for simplicity, we only consider
--- the restriced lambda abstraction here.  Remove the "frozen" attribute
--- below if you want to obtain unrestricted abstraction.
  op /\_ : Exp -> Exp [frozen prec 50] .
  op {_} : Int -> Var .
  op _[_/_] : Exp Exp Int -> [Exp] [prec 10] .
endm


set print with parentheses on .

mod DE-BRUIJN is
  including DE-BRUIJN-SYNTAX .
---...HW5... (equations defining the substitution and lifting, plus one rule for beta-reduction)
  op ^ : Exp Int Int -> Exp . --- lift exp by amount for index
  ops Lup Ldown : Exp -> Exp . --- lift up and lift down by one index

  var E E1 E2 : Exp . var C N M : Int .

--- lifting
  eq Lup(E) = ^(E, 1, 0).
  eq Ldown(E) = ^(E, -1, 0).
  
  eq ^(E1 E2, C, N) = ^(E1, C, N) ^(E2, C, N) .
  eq ^(/\ E, C, N) = /\ ^( E, C, {N +Int 1}) .
  eq ^({M}, C, N) = if M >=Int N then M +Int C else M fi . 

endm

--- Testing De Bruijn
rew (/\ {0}) x .
rew (/\ /\ {0}) x .
rew (/\ /\ {1}) x .
rew (/\ /\ x {1} y) x .


q
