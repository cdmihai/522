*** Copyright 2013, Grigore Rosu (University of Illinois). ***

--- This file contains various definitions of untyped lambda calculi,
--- some based on substitution, others based on combinators, and others
--- based on de Bruijn nameless encodings.  There are four places
--- where the definition can be configured, indicated by comments
--- of the form "!!!SETTING n!!!", with n in {1,2,3,4}.  Specifically,
--- !!!SETTING 1!!! allows to pick a lambda abstraction which is
--- either restricted to prohibit reductions in its body or unrestricted;
--- !!!SETTING 2!!! allows to pick an application operation which is either
--- unrestricted or prohibits reductions in the argument (call-by-name);
--- !!!SETTING 3!!! is only related to de Bruijn and allows to either
--- include the conventional de Bruijn technique or the optimized one;
--- !!!SETTING 4!!! allows to pick a particular kind of lambda calculus, that
--- is, standard, call-by-value, with combinators, or with de Bruijn.

--- Example 01: Substitution-based, standard lambda-calculus; that is,
--- unrestricted lambda-abstraction and unrestricted application
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 02: Substitution-based lambda-calculus
--- with no reductions in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 03: Substitution-based call-by-name lambda-calculus
--- with reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 04: Substitution-based call-by-name lambda-calculus
--- with no reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-STANDARD

--- Example 05: Substitution-based call-by-value lambda-calculus
--- with reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-UNRESTRICTED
---   SETTING 2 = irrelevant
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-CALL-BY-VALUE

--- Example 06: Substitution-based call-by-value lambda-calculus
--- with no reductions allowed in lambda abstractions
---   SETTING 1 = LAMBDA-ABSTRACTION-RESTRICTED
---   SETTING 2 = irrelevant
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-CALL-BY-VALUE

--- Example 07: Combinators-based lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-WITH-COMBINATORS

--- Example 08: Combinators-based lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = irrelevant
---   SETTING 4 = LAMBDA-WITH-COMBINATORS

--- Example 09: De Bruijn lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = DE-BRUIJN
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 10: De Bruijn lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = DE-BRUIJN
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 11: Optimized De Bruijn lambda-calculus, unrestricted application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-UNRESTRICTED
---   SETTING 3 = DE-BRUIJN-OPTIMIZED
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

--- Example 12: Optimized De Bruijn lambda-calculus, call-by-name application
---   SETTING 1 = irrelevant
---   SETTING 2 = APPLICATION-CALL-BY-NAME
---   SETTING 3 = DE-BRUIJN-OPTIMIZED
---   SETTING 4 = LAMBDA-WITH-DE-BRUIJN

in builtins

mod GENERIC-EXPRESSION is
  including PL-ID .
  sorts Var Builtin Exp .
  subsort Id < Var .
  subsort Var Builtin < Exp .
endm

mod LAMBDA-ABSTRACTION-UNRESTRICTED is
  including GENERIC-EXPRESSION .
--- Unrestricted lambda abstraction means that reductions can also take place
--- inside its body.  So no strategy is defined for /\_._
  op /\_._ : Var Exp -> Exp [prec 50] .
endm

mod LAMBDA-ABSTRACTION-RESTRICTED is
  including GENERIC-EXPRESSION .
--- Restricted lambda abstraction means that reductions are forbidden
--- to take place inside its body.  So a strategy is defined for /\_._
  op /\_._ : Var Exp -> Exp [frozen(2) prec 50] .
endm

mod LAMBDA-ABSTRACTION is
--- !!!SETTING 1!!!
--- Pick one of the following:
---  including LAMBDA-ABSTRACTION-UNRESTRICTED .
  including LAMBDA-ABSTRACTION-RESTRICTED .
endm

mod APPLICATION-UNRESTRICTED is
  including GENERIC-EXPRESSION .
--- Unrestricted application means that reductions can take place
--- anywhere (both in the function and in its argument)
  op __ : Exp Exp -> Exp [prec 25 gather(E e)] .  --- left associative, binds tighter than /\_._
endm

mod APPLICATION-CALL-BY-NAME is
  including GENERIC-EXPRESSION .
--- Call-by-name means that only the first argument (the function) of
--- the application needs to be be reduced before the application takes place.
--- The second argument is not reduced at all.
  op __ : Exp Exp -> Exp [frozen(2) prec 25 gather(E e)] .
endm

mod APPLICATION is
--- !!!SETTING 2!!!
--- Pick one of the following:
  including APPLICATION-UNRESTRICTED .
---  including APPLICATION-CALL-BY-NAME .
endm

mod SUBSTITUTION is
  including PL-GENERIC-SUBSTITUTION .
  including LAMBDA-ABSTRACTION .
  subsort Exp < GenericTerm .
  eq bind('/\_._) = 1 .
  op _[_/_] : Exp Exp Var -> Exp .
  vars E F : Exp .  var X : Id .
  eq E[F / X] = substitute(E, F, X) .
endm

mod TEST-SUBSTITUTION is
  including SUBSTITUTION .
  including APPLICATION .
endm

--- Testing substitution (variable capture)
rew (/\ x . /\ y . x y z)[x / z] .
rew (/\ u . /\ x . /\ y . x y z)[x / z] .
rew ((/\ x . x z) (/\ x . /\ y . x y z))[x / z] .

mod LAMBDA-STANDARD is
  including SUBSTITUTION .
  including APPLICATION .
  var X : Var .  var E F : Exp .
--- Comment the next rule out to see how big the deasugared
--- lambda terms are before lambda reduction.
--- Note that sometimes one may get much faster rewrites if one
--- makes the rule below an equation instead of a rule.
--- However, one should be careful with this, because equations
--- do not obey the frozeness declarations, so one will not
--- achieve the desired evaluation strategy; in particular,
--- one may have non-termination where it should terminate.
  rl (/\ X . E) F => E[F / X] .  --- beta reduction
endm

mod LAMBDA-CALL-BY-VALUE is
--- Call-by-value lambda calculus differs from other variants of lambda
--- calculus in that beta reduction is applied only after the two arguments
--- of the application operation are fully evaluated.  To distinguish
--- the fully evaluated expressions from the other, a new syntactic
--- category of values, Val, is typically introduced.  Note that the
--- beta reduction rule below requires F to be of sort Val.
--- Also, note that in addition to variables and builtins, the lambda
--- abstraction is also added as a construct for values.  Maude's
--- least-sort computation mechanism will guarantee that terms are
--- always sorted to Val whenever possible, in spite of the overloaded
--- lambda abstraction.  Call-by-value works best when the lambda-abstraction
--- is restricted to not evaluate its argument, that is, when we include
--- LAMBDA-ABSTRACTION-RESTRICTED in module LAMBDA-ABSTRACTION above.
--- Also, the application operation has to be allowed to evaluate both
--- its arguments, which is why APPLICATION-UNRESTRICTED is included below.
  including SUBSTITUTION .
  including APPLICATION-UNRESTRICTED .
  var X : Var .  var E : Exp .  var F : Val .
  sort Val .
  subsorts Var Builtin < Val < Exp .
  op /\_._ : Var Exp -> Val [ditto] .
  rl (/\ X . E) F => E[F / X] .  --- beta reduction
endm

mod COMBINATORY-LOGIC is
  including APPLICATION .
  ops S K : -> Exp .
  var E F G : Exp .
--- You may comment out the rules below to see how huge
--- the SK representations of even small lambda terms can be.
--- Like in the case of lambda with substitution above, making
--- these rules equations may yield faster executions sometimes,
--- but in general it may lead to unsoundness and non-termination.

  rl K E F => E .
  rl S E F G => E G ( F G ) .
endm

--- Testing combinators
rew S K K x .        --- S K K is the identity
rew S K K (S K K) .  --- S K K is the identity

mod LAMBDA-WITH-COMBINATORS is
  including PL-BOOL .
--- It does not really matter whether we include the restricted
--- or the unrestricted variant of the original lambda-abstraction,
--- because that construct gets eliminated anyway.
  including LAMBDA-ABSTRACTION-UNRESTRICTED .
  including COMBINATORY-LOGIC .

  var X Y : Var . var E F G : Exp .

  op [_] : Var -> Exp .

  eq /\ X . E = [X] E .
  eq [X] Y = if X ==Bool Y then S K K else K Y fi .
  eq [X] E F = S ([X] E) ([X] F) . 
  eq [X] K = K K .
  eq [X] S = K S .

endm

mod DE-BRUIJN-SYNTAX is
  including APPLICATION .
  including PL-INT .
--- Like in the standard lambda-calculus, both restricted and unrestricted
--- lambda abstraction make sense.  However, for simplicity, we only consider
--- the restriced lambda abstraction here.  Remove the "frozen" attribute
--- below if you want to obtain unrestricted abstraction.
  op /\_ : Exp -> Exp [frozen prec 50] .
  op {_} : Int -> Var .
  op _[_/_] : Exp Exp Int -> [Exp] [prec 10] .
endm


---set print with parentheses on .
---set trace on .

mod DE-BRUIJN is
  including DE-BRUIJN-SYNTAX .
---...HW5... (equations defining the substitution and lifting, plus one rule for beta-reduction)
  op ^ : Exp Int Int -> Exp . --- lift exp by amount for index
  ops Lup Ldown : Exp -> Exp . --- lift up and lift down by one index

  var E E' E1 E2 : Exp . var C N M : Int . var X : Id .

--- lifting
  eq Lup(E) = ^(E, 1, 0).
  eq Ldown(E) = ^(E, -1, 0).
  
  eq ^(E1 E2, C, N) = ^(E1, C, N) ^(E2, C, N) .
  eq ^(/\ E, C, N) = /\ ^( E, C, N +Int 1) .
  eq ^({M}, C, N) = if (M >=Int N) then {M +Int C} else {M} fi .
  eq ^(X, C, N) = X .

--- substitution
  eq (E1 E2)[E / {N}] = (E1[E / {N}]) (E2[E / {N}]) .  
  eq (/\ E')[E / {N}] = /\ E'[Lup(E) / {N +Int 1}] .
  eq {M}[E / {N}] = if M ==Bool N then E else {M} fi .
  eq X[E / {N}] = X .

--- beta reduction
  rl (/\ E') E => Ldown(E'[Lup(E) / {0}]) .

endm

--- Testing Lifting
---rew Lup({0}) .
---rew Ldown ({0}) .

---rew Lup({1}) .
---rew Ldown ({1}) .

---rew Lup((/\ {0} {1})) .
---rew Ldown (/\ {0} {1}) .

--- Testing De Bruijn
rew (/\ {0}) x .
rew (/\ /\ {0}) x .
rew (/\ /\ {1}) x .
rew (/\ /\ x {1} y) x .


mod DE-BRUIJN-OPTIMIZED is
  including DE-BRUIJN-SYNTAX .
---...HW5... (equations defining the substitution and lifting, plus one rule for beta-reduction)
  op ^ : Exp Int Int -> Exp . --- lift exp by amount for index
  ops Lup Ldown : Exp -> Exp . --- lift up and lift down by one index

  var E E' E1 E2 : Exp . var C N M : Int . var X : Id .

--- lifting
  eq Lup(E) = ^(E, 1, 0).
  eq Ldown(E) = ^(E, -1, 0).
  
  eq ^(E1 E2, C, N) = ^(E1, C, N) ^(E2, C, N) .
  eq ^(/\ E, C, N) = /\ ^( E, C, N +Int 1) .
  eq ^({M}, C, N) = if (M >=Int N) then {M +Int C} else {M} fi .
  eq ^(X, C, N) = X .

--- substitution
  eq (E1 E2)[E / {N}] = (E1[E / {N}]) (E2[E / {N}]) .  
  eq (/\ E')[E / {N}] = /\ E'[Lup(E) / {N +Int 1}] .
  eq X[E / {N}] = X .

  eq {M}[E / {N}] = if (M ==Bool N) then E else 
                      (if (M >Int N) then {M -Int 1} else {M} fi) 
                    fi .

--- beta reduction
  rl (/\ E') E => E'[E / {0}] .
endm

--- Testing optimized De Bruijn
rew (/\ {0}) x .
rew (/\ /\ {0}) x .
rew (/\ /\ {1}) x .
rew (/\ /\ x {1} y) x .

mod LAMBDA-WITH-DE-BRUIJN is
--- There are (at least) two ways to transform a lambda expression into
--- an equaivalent de Bruijn expression.  One is top down, where one
--- needs to maintain a mapping from variables to "counter" natural numbers,
--- making sure that one increases all the counters as one passes lambdas.
--- Another is bottom up, where one elminates one bound variable at a time
--- and this way one need not worry about maintaining any counter mapping.
--- The former is more involved but faster; the latter is simpler but slower;
--- note, however, that this transformation step is typically cheap anyway
--- compared to the actual computation, so it does not really matter how we
--- do it.   My solution below follows the bottom up approach.

--- It does not really matter whether we include the restricted
--- or the unrestricted variant of the original lambda-abstraction,
--- because that construct gets eliminated anyway.
  including LAMBDA-ABSTRACTION-UNRESTRICTED .
--- !!!SETTING 3!!!
--- Below, include either the classic de Bruijn or the optimized version.
---  including DE-BRUIJN .
  including DE-BRUIJN-OPTIMIZED .

  op de-Bruijn-ify : Exp Var Int -> [Exp] .

  var X Y : Var .  var E E1 E2 : Exp .  var N : Int .  var B : Builtin .

  eq /\ X . E = /\ de-Bruijn-ify(E, X, 0) .
  eq de-Bruijn-ify(E1 E2, X, N) = de-Bruijn-ify(E1, X, N) de-Bruijn-ify(E2, X, N) .
  eq de-Bruijn-ify(Y, X, N) = if X ==Bool Y then {N} else Y fi .

 *** I guess the following rule is not needed since it starts from the innermost lambdas and then goes upward 
 --- eq de-Bruijn-ify(/\ Y . E, X, N) = /\ Y . de-Bruijn-ify(E, X, N +Int 1) . ---assume everything has been alpha converted to uniqueness

  eq de-Bruijn-ify(/\ E, X, N) = /\ de-Bruijn-ify(E, X, N +Int 1) . ---assume everything has been alpha converted to uniqueness

endm

mod LAMBDA is
--- !!!SETTING 4!!!
--- Make sure that the desired computational infrastructure is included below.
---  including LAMBDA-STANDARD .
---  including LAMBDA-CALL-BY-VALUE .
---  including LAMBDA-WITH-COMBINATORS .
  including LAMBDA-WITH-DE-BRUIJN .
endm

--- Testing lambda calculus
rew (/\ x . x) y .
rew (/\ x . x) (/\ x . x) .
rew (/\ f . (/\ x . f x) y) g .           --- non-deterministic but confluent
rew (/\ z . z z)(/\ x . /\ y . x y) .     --- tricky variable capture possible
rew (/\ z . /\ a . /\ b . z a b) (a b)  . --- two fresh variables needed
rew /\ x . x x .                          --- this is fine in isolation
***rew (/\ x . x x)(/\ x . x x) .            --- should not terminate
rew /\ x . f (x x) .
--- The next two should not terminate under unrestricted application
***rew (/\ x . f (x x)) (/\ x . f (x x)) .        
***rew /\ f . (/\ x . f (x x)) (/\ x . f (x x)) .

set trace on .
---rew (/\ f . (/\ x . f x) y) g .           --- non-deterministic but confluent

q
